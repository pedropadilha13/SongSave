# SongSave

Reposit√≥rio para estudar os principais aspectos de Node.js e um pouco mais :)

## √çndice

- [Instala√ß√£o](#instala√ß√£o)

- [npm](#npm)

- [O que faremos?](#o-que-faremos)

- [Criando a estrutura do projeto](#criando-a-estrutura-do-projeto)

- [Vamos entender melhor o que ele criou:](#vamos-entender-melhor-o-que-ele-criou)

- [Instalando as depend√™ncias](#instalando-as-depend√™ncias)

- [Rodando o nosso projeto](#rodando-o-nosso-projeto)

- [O que s√£o rotas?](#o-que-s√£o-rotas)

- [Nodemon](#nodemon)

- [app.js](#appjs)

- [Bootstrap](#bootstrap)

- [Interpolando valores na p√°gina](#interpolando-valores-na-p√°gina)

- [Criando um Banco de Dados](#criando-um-banco-de-dados)

- [Mongoose](#mongoose)

- [db.js](#dbjs)

- [.env](#env)

- [Schemas](#schemas)

- [Recapitulando...](#recapitulando)

- [P√°gina de Login... Ou apenas uma Partial?](#p√°gina-de-login-ou-apenas-uma-partial)

- [O que √© uma Partial View?](#o-que-√©-uma-partial-view)

- [Estilos e Scripts din√¢micos](#estilos-e-Scripts-din√¢micos)

- [Login](#login)

## Instala√ß√£o

Para instalar o Node, baixe o instalador no [site oficial](https://nodejs.org/).

Podemos confirmar que a insta√ß√£o foi conclu√≠da com sucesso executando o comando `node -v`:
![node -v: v14.9.0](assets/images/node-version.PNG)

## npm

**npm** (Node Package Manager), como o pr√≥prio nome j√° diz, √© o gerenciador de pacotes do Node. Quando instalamos o Node, o **npm** j√° vem junto. Podemos confirmar usando o comando `npm -v`:
![node -v: v6.14.8](assets/images/npm-version.PNG)

## O que faremos?

Para aprender os conceitos b√°sicos de Node.js e algumas das principais tecnologias que est√£o √† sua volta, vamos construir um sistema simples onde poderemos cadastrar usu√°rios e suas m√∫sicas favoritas. Vamos l√°!

## Criando a estrutura do projeto

Para fazer o nosso sistema, vamos usar o framework [Express.js](https://expressjs.com/). Ele √© muito todo usado no mundo e extremamente simples de aprender! Para facilitar a nossa vida, o Express j√° tem uma ferramenta que cria uma estrutura de arquivos simples para n√≥s. Para isso, temos que instalar o Express na nossa m√°quina.
Fazemos isso com o comando `npm install -g express`:

![instala√ß√£o do express](assets/images/express-install.PNG)

`install`: instru√ß√£o que queremos executar
`express`: Nome do pacote que queremos instalar
`-g`: Instala o pacote globalmente

Podemos confirmar que a instala√ß√£o funcionu corretamente checando a vers√£o do express (como fizemos anteriormente) utilizando o comando `express --version`:

![express --version: 4.16.0](assets/images/express-version.PNG)

Agora podemos criar o nosso projeto! Em um diret√≥rio vazio (chamei o meu de node-starter, mas voc√™ pode escolher o nome que quiser), vamos executar o comando `express . --view=ejs`.

![cria√ß√£o do template do projeto](assets/images/express-create.PNG)

O meu diret√≥rio j√° tinha alguns arquivos, como [README.md]() e [LICENCE](), por isso tive que confirmar que queria criar o projeto l√° mesmo.

###### Vamos entender melhor o que ele criou:

- [public](/public): diret√≥rio de onde ser√£o servidos recursos est√°ticos (ex. imagens, css, js)
- [routes](/routes): diret√≥rio onde vamos colocar todas as nossas rotas
- [views](/views): diret√≥rio que conter√° nossas views e partials
- [bin](/bin): diret√≥rio que cont√©m o arquivo de inicializa√ß√£o do nosso servidor
- [app.js](app.js): nosso arquivo "principal", onde concentraremos todas as nossas configura√ß√µes
- [package.json](package.json): arquivo que cont√©m todas as nossas depend√™ncias, scripts e detalhes importantes sobre o nosso projeto

## Instalando as depend√™ncias

Para instalar todas as depend√™ncias do projeto (especificadas no arquivo [package.json](package.json)), usamos o comando `npm install`, ou simplesmente `npm i`:

![npm install](assets/images/npm-install.PNG)

Podemos ver que um diret√≥rio chamado **node_modules** foi criado. √â nele que todas as depend√™ncias de um projeto ficam, seja em um ambiente de desenvolvimento (como o nosso) ou um de produ√ß√£o (servidor). √â comum e boa pr√°tica ignorar o **node_modules** inteiro em ferramentas de controle de vers√£o (como o GitHub). Fazemos isso criando um arquivo chamado [.gitignore](.gitignore) e adicionando "node_modules/" a ele. No meu caso, quando criei o reposit√≥rio no GitHub j√° selecionei um modelo de arquivo .gitignore feito para Node.js, que cont√©m as configura√ß√µes mais comuns para este tipo de projeto. (H√° v√°rios tipos, voc√™ pode ver todos os templates em [New Repository](https://github.com/new)).

## Rodando o nosso projeto

Chegou a hora de ver se tudo at√© agora funcionou! Quando o arquivo [package.json](package.json) foi criado, um script chamado "start" foi criado junto. Ele √© uma maneira mais f√°cil que utilizaremos para inicializar o nosso servidor. Podemos ver que ele √© simplesmente um atalho que executa o comando `node ./bin/www`, ou seja, roda com `node` o arquivo [www](www) no diret√≥rio [bin](/bin). Para executar um script, utilizamos o comando `npm run <script>`, ent√£o no nosso caso fazemos `npm run start`:

![npm run start](assets/images/npm-run-start.PNG)

Por padr√£o, o servidor roda na porta 3000. Podemos ent√£o acessar a p√°gina [http://localhost:3000]() para ver se tudo deu certo:

![Welcome to Express](assets/images/welcome-to-express.png)

Oba! Tudo funcionou corretamente e estamos vendo a p√°gina padr√£o do Express sendo renderizada na raiz do site.

## O que s√£o rotas?

Rotas s√£o os caminhos que configuramos para que os servi√ßos que a nossa aplica√ß√£o vai disponibilizar sejam acessados. No nosso caso, por exemplo, criaremos uma rota para manipularmos os usu√°rios e suas m√∫sicas preferidas. Os diferentes "caminhos" de uma API s√£o chamados de **endpoints**.

---

Voc√™ pode perceber que o nosso modelo de projeto j√° veio com duas rotas configuradas, que s√£o os arquivos em [routes/](/routes). Se abrirmos o arquivo [routes/index.js](/routes/index.js), veremos que h√° apenas um endpoint configurado. O m√©todo definido foi GET, no caminho '/' e a fun√ß√£o executada quando o endpoint √© acessado renderiza a **view** [views/index.ejs](/views/index.ejs), passando um par√¢metro chamado _title_ com o valor _Express_. Se trocarmos este valor:

![title: node](/assets/images/title-node.png)

e acessarmos novamente a p√°gina em [http://localhost:3000](), veremos que o texto... Continua o mesmo! Por que ser√°? ü§î

H√° alguns minutos, n√≥s iniciamos o nosso servidor, e em n√£o fizemos nenhum tipo de atualiza√ß√£o nele. Em outras palavras, ele n√£o tem a menor ideia de que n√≥s mudamos alguma coisa no nosso c√≥digo. Para que as nossas mudan√ßas fa√ßam efeito, devemos parar a execu√ß√£o do servidor, e depois inici√°-la novamente. Paramos a execu√ß√£o de algum processo com o comando `Ctrl+C`, e depois usamos o mesmo comando de antes:

![restart server](/assets/images/restart-server.png)

Se acessarmos a p√°gina novamente, poderemos ver que a nossa mudan√ßa fez efeito!

![Welcome to Node](/assets/images/welcome-to-node.png)

## Nodemon

Como voc√™ pode imaginar, √© muito trabalhoso e nem um pouco eficiente ter que ir para o terminal, parar o servidor e inici√°-lo novamente a cada mudan√ßa que fazemos no nosso c√≥digo. Para a nossa comodidade, existe um pacote que faz exatamente isso para n√≥s! Para instalar, basta executar o comando `npm install -g nodemon`. Depois de instalado, podemos verificar que est√° tudo certo usando o comando `nodemon -v`, que mostra a vers√£o do nodemon instalada:

![nodemon -v: 2.0.4](/assets/images/nodemon-version.png)

No arquivo [package.json](/package.json), vamos criar um novo script para que o servidor se reinicie automaticamente. Em `"scripts"`, vamos adicionar mais uma entrada. Vou chamar o meu de `watch`, mas n√£o √© obrigat√≥rio que ele seja chamado assim.

!["watch": "nodemon ./bin/www"](/assets/images/watch-script.png)

_√â importante observar que arquivos com a extens√£o JSON devem, **obrigatoriamente**, conter chaves e valores envolvidos com **aspas duplas (")**._

Se executarmos agora `npm run watch`, veremos que o servidor √© reiniciado toda vez que um arquivo √© atualizado, fazendo com que sempre tenhamos a vers√£o mais recente do nosso programa sendo executada sem a necessidade de fazer todo o processo de reinicializa√ß√£o manualmente.

## [app.js](/app.js)

‚òùÔ∏è Clique aqui para abrir o arquivo, nele est√£o alguns coment√°rios :)

## Bootstrap

Para deixarmos nosso sistema visualmente apresent√°vel, vamos usar [Bootstrap](https://getbootstrap.com/). Como o foco aqui √© mais backend e n√£o o design da aplica√ß√£o em si, n√£o focaremos muito em CSS e estiliza√ß√£o em geral.

Podemos usar o [template](https://getbootstrap.com/docs/4.5/getting-started/introduction/#starter-template) para come√ßar o nosso desenvolvimento.

## Interpolando valores na p√°gina

Em [views](/views), vamos criar um novo arquivo chamado [main.ejs](views/main.ejs) e colar o template nele. Podemos testar que est√° funcionando apenas mudando o arquivo que √© renderizado em [routes/index.js](routes/index.js) e atualizando a p√°gina em nosso navegador:

![res.render('main');](/assets/images/render-main.PNG)

![Hello World](/assets/images/hello-world.PNG)

Est√° tudo funcionando, √≥timo! Msa n√£o queremos sempre mostrar uma mensagem "Hello World" para os visitantes do site. J√° vimos que podemos passar informa√ß√µes do nosso servidor direto para a p√°gina apenas adicionando um objeto depois do nome da _view_ que queremos renderizar. Vamos relembrar! No nosso render, vamos adicionar um objeto que cont√©m um nome:

![res.render('main', { name: 'Jo√£ozinho' });](/assets/images/render-with-name.PNG)

Na nossa _view_, podemos adicionar `<% name %>` para interpolar o valor da nossa vari√°vel!

![Hello, <% name %>!](/assets/images/hello-name.PNG)

Pronto! Agora se atualizarmos o navegador veremos a mensagem nova:

![Hello, Jo√£ozinho!](/assets/images/hello-joaozinho.PNG)

Podemos passar quantos atributos quisermos para a _view_, e vimos que √© bem simples exibir os valores. Mais para frente veremos que tamb√©m √© poss√≠vel, por exemplo, iterar todos os itens de um Array passado para uma _view_ e exibir todos os valores de forma f√°cil e elegante.

## Criando um Banco de Dados

Para a nossa aplica√ß√£o, vamos usar o MongoDB. Para isso, precisamos ter uma conta no [Atlas](https://cloud.mongodb.com/) (n√£o se preocupe, √© de gra√ßa). Para criar _Projects_, precisamos antes ter uma _Organization_ criada. Basta seguir os passos que o pr√≥prio site mostra para fazer isso de forma extremamente f√°cil. Com uma _Organization_ criada, podemos criar um novo Projeto Clicando em "_+ New Project_". Chamei o meu de SongSave, mas voc√™ pode chamar o seu do nome que quiser!

Depois de criarmos o projeto, devemos criar um _Cluster_. Para isso, basta clicar no bot√£o "_Build a Cluster_", selecionar a primeira alternativa (free), e clicar em "_Create a Cluster_". √â poss√≠vel tamb√©m dar um nome ao seu Cluster (o padr√£o √© "Cluster0", que pode causar confus√£o). Vou nomear o meu "songsave", para ficar f√°cil. O processo de cria√ß√£o n√£o demora mais que 5 minutos, e enquanto ele √© executado, j√° podemos criar nosso usu√°rio para acessar o banco. Clique em "Database Access" no menu lateral, e em seguida "Add New Database User". Temos que dar um nome e uma senha ao usu√°rio. Darei novamente o nome de "songsave", apenas para ficar f√°cil de lembrar. Clicando em "Autogenerate Secure Password", uma senha ser√° gerada. Lembre-se de copiar a senha e guard√°-la em um local seguro, porque n√£o √© poss√≠vel visualiz√°-la depois. (Podemos sempre criar uma senha nova, mas em seguida vamos conectar o nosso servidor ao Mongo, e n√£o precisaremos mais nos preocupar com a senha)

Para fazermos a conex√£o, precisamos de algumas informa√ß√µes importantes, como o usu√°rio e senha que criamos, nome do banco e o local do servidor. Tudo isso pode ser encontrado no que chamamos de _connection string_, que pode ser obtida clicando em _CONNECT_ no nosso Cluster.

Voc√™ dever√° liberar o seu IP para acessar o banco, pois o servidor s√≥ aceita conex√µes de clientes que est√£o presentes em uma whitelist. Voc√™ pode liberar todos os IPs, embora n√£o seja recomendado por quest√µes de seguran√ßa. Depois disso, escolha o m√©todo que permite conectar a sua aplica√ß√£o e copie a _connection string_ fornecida. Note que nela h√° um espa√ßo onde est√° o texto `<password>`. Voc√™ dever√° substitu√≠-lo pela sua senha para que a conex√£o seja realizada. Voc√™ deve, tamb√©m, substituir `<dbname>` pelo nome do seu banco. No meu caso, chamei o banco de `dev` (estamos em um ambiente de desenvolvimento, por isso o nosso banco ser√° dev. Quando fizermos o deploy do nosso sistema, vamos trocar o banco para `prod`, garantindo assim que n√£o haver√° interfer√™ncia de um ambiente no outro).

## Mongoose

Para conectar o nosso servidor ao banco, vamos usar um pacote chamado [Mongoose](https://mongoosejs.com/). Para instal√°-lo, simplesmente executamos `npm install mongoose` no nosso terminal:

![npm install mongoose](/assets/images/npm-install-mongoose.PNG)

## [db.js](/services/db.js)

Para organizar melhor os servi√ßos do nosso sistema, vamos criar uma pasta [services](/services). Agora, dentro dela, vamos criar um arquivo [db.js](services/db.js) para conectar o nosso servidor ao banco. Nele, devemos importar o **mongoose** com a seguinte instru√ß√£o:

```javascript
const mongoose = require('mongoose');
```

Depois, criamos uma fun√ß√£o chamada connectDB, nela inserimos um bloco try/catch. Dentro dele, tentaremos iniciar a conex√£o com o banco. Note que aqui devemos inserir a nossa _connection string_ completa:

```javascript
const connectDB = async () => {
  try {
    const conn = await mongoose.connect(
      'mongodb+srv://songsave:gxgDJWcvHrMmCn65@cluster0.ky6xj.mongodb.net/dev?retryWrites=true&w=majority',
      {
        useNewUrlParser: true,
        useUnifiedTopology: true
      }
    );
    console.log('MongoDB connected');
  } catch (error) {
    console.error(error);
  }
};
```

(Caso haja d√∫vidas a respeito da sintaxe utilizada, voc√™ pode ler um pouco mais aqui: [Arrow function expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions))

Finalmente, exportamos a nossa fun√ß√£o no fim do arquivo:

```javascript
module.exports = connectDB;
```

Voltando ao [app.js](app.js), importamos e logo abaixo j√° invocamos a nossa fun√ß√£o:

```javascript
const connectDB = require('./services/db');

connectDB();
```

Se tudo der certo, a mensagem "MongoDB connected" aparecer√° no console:

![MongoDB connected](/assets/images/mongodb-connected.PNG)

Caso um erro ocorra, certifique-se de que:

- seu nome de usu√°rio e senha est√£o corretos
- seu IP atual est√° com acesso liberado no Atlas
- a senha **n√£o** est√° com os caracteres '<' e '>' em volta

## .env

Por motivos de seguran√ßa, **nunca** deixamos dados sens√≠veis no nosso c√≥digo. Um exemplo √© a nossa _connection string_. Ela d√° acesso ao nosso banco de dados, ent√£o n√£o faz sentido deixar qualquer pessoa ter acesso a ela. Para isso, vamos utilizar **Vari√°veis de Ambiente**. Vamos criar um arquivo [.env](.env), e nele adicionar as nossas informa√ß√µes secretas. Logicamente, arquivos .env tamb√©m nunca fazem parte do nosso controle de vers√£o (ou seja, n√£o vamos subir para o reposit√≥rio). Al√©m de ser muito f√°cil, essa abordagem que vamos utilizar vai facilitar a nossa vida mais para frente!

No nosso [.env](.env), devemos simplesmente colocar `chave=valor`, sem nenhum tipo de nota√ß√£o complicada:

```
MONGO_URI=mongodb+srv://songsave:gxgDJWcvHrMmCn65@cluster0.ky6xj.mongodb.net/dev?retryWrites=true&w=majority
```

O nosso servidor n√£o sabe que queremos usar essas Vari√°veis de Ambiente, ent√£o temos que explicar isso para ele! Faremos isso usando o pacote [dotenv](https://www.npmjs.com/package/dotenv):

![npm install dotenv](assets/images/npm-install-dotenv.PNG)

Agora fazemos a inicializa√ß√£o no topo do nosso [app.js](app.js):

```javascript
require('dotenv').config();
```

Agora, em [db.js](services/db.js) fazemos a seguinte chamada:

```javascript
const conn = await mongoose.connect(process.env.MONGO_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true
});
```

Pronto! Se rodarmos o nosso script `watch` novamente, vamos ver que tudo est√° funcionando ainda, e n√£o temos que nos preocupar com pessoas erradas tendo acesso ao nosso banco, chaves de APIs, ou qualquer informa√ß√£o coisa privada.

![MongoDB connected](assets/images/dotenv-ok.PNG)

## Schemas

Agora que temos a nossa conex√£o funcionando normalmente, podemos come√ßar a pensar nas Entidades que nosso sistema vai ter. Temos que ter um Schema para guardar nosso usu√°rios e outro para guardar as playlists que eles v√£o criar. Vou criar um diret√≥rio [models/](/models), e nele criaremos os seguintes arquivos:

- [User.js](models/User.js)
- [Link.js](models/Link.js)
- [Playlist.js](models/Playlist.js)

Em [User.js](models/User.js), fazemos uso do m√≥dulo `bcrypt`, ent√£o n√£o devemos nos esquecer de executar o comando `npm install bcrypt` no terminal.

Agora, no [app.js](app.js), devemos importar os 3 arquivos criados. Vamos fazer isso logo antes de conectarmos ao banco:

```javascript
const connectDB = require('./services/db');
require('./models/User');
require('./models/Link');
require('./models/Playlist');

connectDB();
```

Com as mudan√ßas que fizemos, agora j√° podemos come√ßar a desenvolver nosso sistema de verdade!

## Recapitulando...

Vamos lembrar, de forma geral, o que fizemos at√© agora:

- Criamos o projeto usando o template do [Express.js](https://expressjs.com/)
- Criamos um Banco de Dados no [Atlas](https://cloud.mongodb.com/)
- Conectamos nossa aplica√ß√£o ao Banco
- Criamos Schemas para armazenar dados

Agora vamos come√ßar a desenvolver nossa primeira tela!

## P√°gina de Login... Ou apenas uma Partial?

Para identificarmos quem √© quem no nosso sistema, vamos implementar as fun√ß√µes de **Cadastro** e **Login**. Poder√≠amos fazer uma p√°gina para cada, e depois uma p√°gina diferente para as √°reas restritas do site, mas vamos fazer diferente: teremos uma p√°gina "master", e vamos inserir outras p√°ginas menores dentro dela. Faremos isso usando _Partial Views_.

##### O que √© uma Partial View?

√â, de forma simplificada, uma _View_ que √© encaixada dentro de outra. Lembra quando inserimos "Jo√£ozinho" na nossa p√°gina pelo `render`? Faremos a mesma coisa agora, mas inserindo outras p√°ginas e componentes em vez de texto apenas.

Dentro de [views](/views), vamos criar o diret√≥rio [shared](/views/shared) para guardar os peda√ßos que vamos compartilhar entre as diferentes p√°ginas.

J√° temos o arquivo [views/main.ejs](/views/main.ejs), e vamos us√°-lo como "master". Podemos fazer alguns refatoramentos para facilitar n√£o s√≥ uma poss√≠vel manuten√ß√£o futura, mas tamb√©m nosso entendimento agora.

Podemos separar as principais √°reas do [main.ejs](views/main.ejs) atual em peda√ßos menores, e depois inclu√≠-los de volta:

- [\_header.ejs](views/shared/_header.ejs)
- [\_scripts.ejs](views/shared/scripts.ejs)

Depois, basta incluir os fragmentos da seguinte forma: `<% include caminho/para/partial %>`

![main.ejs](/assets/images/main-ejs-refactor.png)

Veja como nosso arquivo [main.ejs](views/main.ejs) ficou muito menor e f√°cil de entender. Quando separamos nossas diferentes partes do sistema em peda√ßos menores, fica muito mais f√°cil adicionar novas funcionalidades, modificar as que j√° existem e principalmente resolver potenciais erros que seu sistema possa apresentar, tanto em desenvolvimento quanto em produ√ß√£o.

Agora, vamos criar uma p√°gina de **Login** e inser√≠-la na nossa view principal:

[/views/login.ejs](/views/login.ejs)

E inserimos `<% include login %>` na _view_ principal.

Um teste r√°pido mostra que estamos inserindo corretamente:

![Login](/assets/images/include-login.png)

Vamos mover "Hello, Jo√£ozinho!" para uma nova partial, [index.ejs](views/index.ejs) e tirar o √∫ltimo include que fizemos para testar.

Para renderizar uma p√°gina espec√≠fica, vamos passar o argumento `page` no segundo argumento de `render`. Recebemos isso no nosso [main.ejs](views/main.ejs) assim:

![include(locals.page || 'index')](/assets/images/include-page-or-index.png)

`locals` √© onde recebemos os argumentos na _view_. Como vimos, podemos usar apenas o nome de algum argumento, mas se ele n√£o existir um erro acontece. Usando `locals`, evitamos esse comportamento.

Perceba que n√£o estamos apenas incluindo uma p√°gina, mas fazemos um teste l√≥gico tamb√©m: Se locals.page existir, ele ser√° usado, mas caso o valor dele seja `falsy`, a _view_ `index` ser√° inclu√≠da por padr√£o. Um valor √© `falsy` quando √© considerado `false` em uma situa√ß√£o de compara√ß√£o l√≥gica. S√£o eles:

```javascript
undefined, null, NaN, 0, '' e false
```

Com isso, podemos fazer um teste e verificar que tudo est√° funcionando como esperado, basta fazer uma pequena modifica√ß√£o na nossa rota principal:

```javascript
router.get('/', function (req, res, next) {
  res.render('main', { page: 'login' });
});
```

![Login](/assets/images/render-page-login.png)

Agora que j√° temos como escolher qual p√°gina vamos mostrar de forma simples, vamos come√ßar a separar melhor as nossas rotas:

Vou criar um arquivo novo para armazenar todas as nossas rotas relacionadas a **autentica√ß√£o**, [auth.js](/routes/auth.js). Vamos come√ßar com uma rota b√°sica:

```javascript
const express = require('express');
const router = express.Router();

router.get('/', (req, res) => {
  return res.render('main', {
    page: 'login'
  });
});

module.exports = router;
```

Podemos apagar a rota que veio configurada, [users.js](/routes/users.js), n√£o esquecendo de apagar o `require` e o `use` no [app.js](app.js).

No lugar dele, vamos incluir nossa authRoute e us√°-la:

```javascript
[...]

const indexRouter = require('./routes/index');
const authRouter = require('./routes/auth');

[...]

app.use('/', indexRouter);
app.use('/auth', authRouter);

[...]
```

Agora, se navegarmos at√© [http://localhost:3000/auth](http://localhost:3000/auth), vamos ver que a p√°gina certa apareceu:

![localhost:3000/auth Login](assets/images/localhost-auth.png)

Perceba que o t√≠tulo da p√°gina √© sempre o mesmo, "Hello, world!". Podemos usar a mesma t√©cnica para mudar o t√≠tulo de acordo com a p√°gina que estamos renderizando. Em [\_header.ejs](/views/shared/_header.ejs), vamos mudar a tag `<title>`:

![<%= locals.title || "SongSave" %>](/assets/images/locals-title.png)

Assim, podemos sempre escolher qual ser√° o t√≠tulo da p√°gina, e garantimos que "SongSave" aparecer√° quando n√£o especificarmos nada.

## Estilos e Scripts din√¢micos

Outra mudan√ßa interessante que faremos √© adicionar a possibiidade de carregar arquivos **css** e **js** direto do `render`, que √© √∫til para arquivos que s√≥ ser√£o usados em algumas p√°ginas espec√≠ficas:

Vamos criar uma nova _Partial View_ chamada [\_styles.ejs](/views/shared/_styles.ejs):

```
<% locals.styles && styles.forEach(style => {
    if (style.substr(0, 4) !== "http") { %>
        <link rel="stylesheet"
            href="/assets/css/<%= style.match(/[a-z0-9]{0,}\.css$/gi) ? style : `${style}.css?version=${parseInt(Math.random() * 10000000)}` %>" />
    <% } else { %>
        <link rel="stylesheet" href="<%= style %>" />
    <% } %>
<% }); %>
```

Pode parecer meio complicado, mas na verdade tudo que fazemos aqui √© iterar por todos os `styles` fornecidos, e para cada um fazemos um pequeno teste: se ele n√£o come√ßar com 'http', ou seja, se n√£o for um link externo, inclu√≠mos o arquivo do diret√≥rio `/assets/css/`, e caso o caminho seja um link, inclu√≠mos normalmente.

N√£o podemos nos esquecer de incluir a nossa nova partial em [\_header.ejs](/views/shared/_header.ejs)

<% include \_styles %>

Faremos a mesma coisa para arquivos JS em [\_scripts.ejs](/views/shared/_scripts.ejs).

```ejs
[...]
<% locals.scripts && scripts.forEach(script => { %>
<script
  src="/assets/js/<%= script.match(/[a-z0-9]{0,}\.js$/gi) ? script : `${script}.js?version=${parseInt(Math.random() * 10000000)}` %>"></script>
<% }); %>
```

Agora, se adicionarmos `styles: ['login']` ao nosso render, vamos ver que o arquivo _login.css_ vai ser carregado pela nossa p√°gina:

![login.css](/assets/images/login-network.png]

Podemos ent√£o criar estilos espec√≠ficos para algumas p√°ginas, e n√£o ter apenas um arquivo gigante com todo o estilo do site inteiro. Mais uma vez, facilitando o entendimento e evitando erros.

## Login

Agora j√° temos tudo para criar nosso layout de Login!

[login.ejs](views/_login.ejs)

[login.css](public/assets/css/login.css)

Se tentarmos enviar o formul√°rio, vamos ver que recebemos um erro 404 de volta. Isso acontece porque o navegador tenta fazer um POST em /auth, mas ainda n√£o implementamos o m√©todo POST em [auth.js](/routes/auth.js). Vamos fazer isso agora!
